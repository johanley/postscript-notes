<!DOCTYPE html>
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <meta name="keywords" content="PostScript, Adobe, PDF">
 <meta name="description" content="PostScript Basics.">
 <meta name="viewport" content="width=device-width"> 
 <link rel="stylesheet" type="text/css" href="stylesheet.css?v=2" media="all"> 
 <title>PostScript Basics</title>
</head>

<body>

<h2>PostScript Basics</h2>

<ul>
 <li>Adobe's first product
 <li>three versions/levels (1985-1999)
 <li>page description language
 <li>centered on graphics (including text)
 <li>about 385 built-in operators
 <li>PS is the precursor to PDF
 <li>PS and PDF: significant overlap, with differences
</ul>

(<em>Fun fact: in the 1980s, the most powerful computer in a typical office was the printer.</em>)
 
<h2>PostScript Got It Right</h2>
<ul>
  <li>many tools are similar to PostScript 
  <li>Javascript's <a href='https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D'>canvas</a> is an example
  <li><a href='https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html'>Graphics2D</a> in Java is another
</ul> 
 
<h2>Basic Use</h2>
<ul>
 <li>generate PS as an intermediate output, then convert to PDF
 <li>code (Java, Python, etc.) -&gt; PS -&gt; PDF
 <li>use case: report generation
</ul>

(<em>Fun fact: James Gosling, the creator of Java, made a <a href='https://www.youtube.com/watch?v=4zG0uecYSMA'>windowing system</a> based on PostScript.</em>)

<h2>Convert PS to PDF</h2>
<ul>
 <li><a href='https://www.ghostscript.com/'>Ghostscript</a> 
 <li>Adobe's Distiller (part of Acrobat)
 <li>this operation is trivial (don't worry about it)
 <li>it's also very fast
</ul>

<h2>Interesting Parts</h2>
<ul>
 <li>postfix notation
 <li>operand stack (pass args, return data)
 <li>very curt, little syntax
 <li>tokenizes an incoming stream of code
 <li>no program counter! (pointer to the line being executed)
 <li><a href='https://en.wikipedia.org/wiki/Lisp_(programming_language)'>LISP</a>-like, with code-as-data
 <li>dynamic namespace
 <li>implicit types
 <li>no type for text or characters
 <li>no keywords! 
 <li>you can override built-in operators (not recommended)
</ul>

<h2>Unpleasant Parts</h2>
<ul>
 <li>harder to read than average
 <li>you need to track state in your head
 <li>minimal tooling
 <li>very few third-party libraries 
 <li>seemingly out of fashion 
</ul>

<h2>Pleasant Parts</h2>
<ul>
 <li>excellent documentation (the <a href='https://www.adobe.com/jp/print/postscript/pdfs/PLRM.pdf'>Red Book</a>)
 <li>fast development
 <li>scalable vector everything
 <li>feelings of power, precise control
 <li>building charts, tables is fairly easy and natural
 <li>tools convert PS to PDF very quickly
 <li>Eclipse <a href="https://marketplace.eclipse.org/content/postscript-development-tools#details">plugin</a>? (unsigned code)
</ul>

<h2>Your Data Exists In Two Places</h2>
<ul>
 <li>the operand stack (where it has no name) - an input-output mechanism
 <li>the dictionary stack (where it has a name) - the namespace
</ul>

<h2>Basic Syntax</h2>
Literals:
<ul>
 <li>string: <code>(blah)</code>
 <li>name (identifier): <code>/blah</code>
 <li>array: <code>[1 2 3 (blah) false]</code>
 <li>dictionary (dict): <code>&lt;&lt;(name)(Bob) (age)28 (silly?)true&gt;&gt;</code> - key-value pairs, in order 
 <li>procedure (proc): <code>{0.01 mul mul}</code> - an executable array of tokens
</ul>

<P>Comments:
<ul>
 <li>comment: <code>% This is a comment</code> 
 <li>comment: <code>%%Title: My Lovely Document</code> - a Document Structuring Convention (DSC) comment 
</ul>

<P>The documentation of a proc is with simple comments (input and output, for example).


<h2>How to make a simple PDF</h2>

The idea is to make a PDF by first generating an intermediate PS file.

<P>1. Text file with this content (8859-1 encoding):
<pre>
%!PS-Adobe-3.0

/Helvetica 48 selectfont
300 500  moveto
(Hello) show

showpage
</pre>

2. Run Ghostscript (or Adobe's Distiller) to read in PS and output PDF:
<pre>
 C:\ghostscript\gs10.04.0\bin>
   gswin64c.exe 
   -dNOSAFER 
   -sDEVICE=pdfwrite  
   -o C:\temp\hello.pdf  
   C:\temp\hello.ps
</pre>

<P>3. View the output: <a href="https://github.com/johanley/postscript-notes/tree/master/examples/hello.pdf">hello.pdf</a>
 
<P>
This toy example is a <a href='https://stevemcconnell.com/books/'>coding horror</a>, because it's hard-coded to a specific page size. 
The tasteful way is to define the page format in one place, and to <b>use percentages everywhere in your code</b>.
(PostScript's <em>scale</em> operator doesn't help if the aspect ratio changes.)

<P>This lets your output be <em>responsive</em> to changes in the width/height.

<P>A more tasteful version:
<pre>
%!PS-Adobe-3.0

<em>% set the format explicitly</em>
<em>% 72 = 1 inch, so this means 3" x 4"</em>
/page-width 3.0 72 mul def % 216
/page-height 4.0 72 mul def % 288 
&lt;&lt;/PageSize [page-width  page-height]&gt;&gt; setpagedevice  

<em>% define a simple 'proc' (procedure) for percentages
% pass two numbers; a value and a percent
% example 'page-width 15 pct' is 15% of the page-width</em>
/pct {
 <em>% the current operand stack (for example):
 % page-width 15</em>  
 0.01  <em>% page-width 15 0.01</em>
 mul   <em>% page-width 0.15</em>
 mul   <em>% 32.4  (result left on the operand stack)</em>
} def

/Helvetica 16 selectfont

page-width 25 pct 
page-height 70 pct  moveto

(Hello again...) show

showpage
</pre>
<P>Output: <a href="https://github.com/johanley/postscript-notes/tree/master/examples/hello-again.pdf">hello-again.pdf</a>

<h2>Dynamic Namespace: Dictionary Stack</h2>
<ul>
 <li>a dictionary (map) is a table of key-value pairs
 <li>keys are unique
 <li>you <em>look up</em> a value using a given key
 <li>keys can be anything, but are usually strings or names
 <li>(PostScript coerces string-keys into name-keys)
</ul> 

PostScript use a <em>stack of dictionaries</em> for its namespace:
<ul>
 <li><em>systemdict</em> on the bottom has the built-in operators
 <li>next is <em>globaldict</em> - for experts only (ignore it)
 <li><em>userdict</em> is there for your code
 <li><em>systemdict</em>, <em>globaldict</em> and <em>userdict</em> can't be removed  
 <li>you can (and often do) build your own dictionaries on top of these 
 <li><em>begin</em> and <em>end</em> create and destroy dicts (push and pop)
 <li>the ones you build are usually transient (per-proc), removed when no longer needed
 <li>key lookup is top-down, down through the stack
</ul> 


<h2>Loops, Prolog + Script</h2>

Looping operators:
<ul>
 <li><code>forall</code>
 <li><code>for</code>
 <li><code>repeat</code>
</ul>

<P>An important idea is the separation of code into two parts:
<ul>
 <li><b>prolog</b> - at the top, where you define procedures
 <li><b>script</b> - at the bottom, where you call procedures and pass the appropriate data
</ul>

<P><b>The prolog is usually written by hand, and the script is usually generated by a program that you write.</b>

<pre>
%!PS-Adobe-3.0

/wd 3.0 72 mul def % 216
/ht 4.0 72 mul def % 288 
<</PageSize [wd ht]>> setpagedevice  
/pct { 0.01  mul  mul  } def
/sbuff 20 string def % string buffer for cvs
/Helvetica 8 selectfont

/show-it {
  <em>% COMMON IDIOM: a temporary dict</em>
  1 dict begin    % temp dict!
    /sbuff 20 string def  <em>% string buffer for cvs</em>
    sbuff cvs      <em>% convert arg into a string</em>
    show           <em>% pop the temp dict off the dict-stack</em>
  end
} def

<em>% dict x y -> print the data-dict key-value pairs
% example input:
%  &lt;&lt;(name)(Annapurna) (height)8030 (country)(Nepal)&gt;&gt; 100 200</em>
/oh-mighty-mountain {
  moveto     <em>% eats the x y on the stack</em>
  { <em>% puts each key-value pair the operand stack
    % WARNING: iteration order is not specified for a dict!
    % WARNING: (height) coerced by PS into /height!
    % /height 8030
    % swap the two top items on the stack</em>
    exch          <em>%  8030 /height  </em>
    
    <em>% cvs converts objects to strings</em>
    show-it   <em>% 8030</em> 
    
    (:) show   <em>% 8030</em> 
    show-it
    
    ( ) show   <em>% spacing</em>
  } forall     <em>% iterate over all key-value pairs</em>
} def

% array x y -> print the array items
% example input:
%  [(Mercury) (Venus) (Earth) (Mars)] 100 200
/oh-glorious-planets {
  moveto % eats the x y on the stack
  { % puts each array-item on the stack in sequence
    show-it
    ( ) show % spacing
  } forall
} def

<em>% THIS IS AN IMPORTANT PATTERN: procs defined first, then pass 
% a data structure to the proc (in practice, usually a dict).
%
% PROLOG: the procs at the top (hand-crafted!).
% SCRIPT: the part where a data structure is passed 
% to the procs (generated by a program!).</em>

&lt;&lt;(name)(Annapurna) (height)8091 (country)(Nepal)&gt;&gt;
wd 5 pct  ht 90 pct
oh-mighty-mountain

[(Mercury) (Venus) (Earth) (Mars)] 
wd 5 pct  ht 80 pct
oh-glorious-planets

showpage</pre>

<P>Output: <a href="https://github.com/johanley/postscript-notes/tree/master/examples/loops.pdf">loops.pdf</a>

</body>
</html>