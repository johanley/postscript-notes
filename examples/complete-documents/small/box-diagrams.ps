%!PS-Adobe-3.0
%%Title: Diagram About Box Diagrams
%%Version: 1.0
%%Creator: John O'Hanley
%%CreationDate: 2026-02-10
%%LanguageLevel: 3.0
%%DocumentMedia: Plain 612.0 792.0 60 white ()
%%DocumentNeededResources: font Helvetica Helvetica-Oblique Helvetica-Bold Consolas
%%BoundingBox: 0 0 612 792
%%Orientation: Portrait 
%%Pages: 1
%%EndComments 

% -- END OF THE HEADER --

% Lines in PostScript should not be more than 255 characters.

%%BeginDefaults 
%%EndDefaults

%%BeginProlog
  % Only procedure definitions go here. 
  % Here, the prolog procs are placed into userdict.
  % Diagram data is placed higher on the dictionary stack.

% DEBUGGING -----

% str
% if you have no debugger, this can help find the exact location of a problem, by 
% planting various calls to this proc around the code with the problem.
/here {
 ==
} bind def

% str 
% the str is a debugging remark sent to stdout
% show everything on the operand stack (but leave the stack intact)
/dump-stack {
  ==
  (-- operand stack {) ==
  pstack 
  (-- }) ==
} def

% dict
% shows the keys and values of the given dict on stdout
/list-dict {
 { == ==  } forall
} bind def

% str 
% the str is a debugging remark sent to stdout
% show the contents of the currentdict (keys and values)
/dump-current-dict {
  ==
  (-- currentdict {) ==
  currentdict list-dict
  (-- }) ==
} def

% str
% the str is a debugging remark sent to stdout
% show the key-names of the currentdict
/dump-keys {
  ==
  (-- currentdict keys {) ==
  currentdict {pop ==} forall
  (-- }) ==
} def

% str
% show a useful message on standard-out, and dump the contents of the operand stack to stdout.
% the passed error message should use ALL CAPS. 
/error-message {
  dump-stack
} bind def

% size-r 
% debugging - show the location of the currentpoint 
% the +X-axis is in red, the +Y-axis in green
% the currentpoint must exist
% pass a representative size for the marks made by this proc
/show-currentpoint {
3 dict begin 
  gsave
   /r exch def
   currentpoint   
   /y exch def
   /x exch def
   r 0.1 mul setlinewidth
   
   % circle in red
   0.5 0 0 setrgbcolor
   newpath    % we want the currentpoint, but not the currentpath           
   x y moveto
   x y r 0 360 arc 
   stroke

   % x-axis in red
   x y moveto        
   r neg 0   rmoveto 
   r 3 mul 0 rlineto % horizontal
   stroke
   
   % y-axis in green
   0 0.5 0 setrgbcolor
   x y moveto  
   0 r neg  rmoveto 
   0 r 3 mul rlineto % vertical
   stroke
  grestore
end
} def

% str
% show the bounding box of the given string, at the currentpoint (which must exist).
/show-text-bbox {
  gsave
    % the bounding box of the text
    false charpath flattenpath pathbbox % x0 y0 x1 y1
    4 array astore % [x0 y0 x1 y1] 
    1 dict begin 
      /box exch def 
      box 0 get 
      box 1 get 
      box 2 get  box 0 get  sub 
      box 3 get  box 1 get  sub 
      rectstroke
    end
  grestore
} def


% MISCELLANEOUS -------------------------

% key 
% return true iff the key is in the currentdict
/is-known {
 currentdict exch known
} bind def

% key
% 'un-def' the given key from the currentdict
/discard {
 currentdict exch undef  
} bind def

% array
% return the last item in an array
/last-entry {
  dup  length 1 sub   get
} def


% GEOMETRY AND MATH ------------------

% pass two numbers; a value and a percent
% example '70 15 pct' is 15% of 70
% note that 15% is represented here as '15', not as '0.15'
% this simple proc is very widely used!
/pct {
 0.01 mul mul
} bind def

% min max pct
% 10 20 50 pct-between returns 15
/pct-between {
  3 dict begin 
    /pct-between exch def 
    /max exch def 
    /min exch def
    max min sub pct-between pct 
    min add    
  end
} def

% [] of numbers
% return the max value for the given array of numbers.
/max {
  1 dict begin
    /max-result -1000000 def
    {
     dup
     max-result gt 
       {/max-result exch def}
       {pop}
     ifelse
    } forall
    max-result
  end
} def

% val size min max 
% size * (val - min)/(max - min)
% linear proportion (0..size): change a val from source data to the user-space coords
/rescale {
 4 dict begin
  /max exch def
  /min exch def
  /size exch def
  /val exch def
  val min sub
  max min sub div
  size mul
 end
} def

% a b 
% return the arithmetic mean of two numbers
/midpoint {
  add 2 div
} def

% [[xy]] - an array of points
% return the bounding box [llx lly urx ury] of a path built from the given array of points
% from the bounding box, the caller can read off the min-max of either x or y (for the given array of points).
% (the path is temporary, and doesn't persist after calling this proc.)
/points-bbox {
  % make a path, and compute its bbox in the current CTM
  newpath % just in case 
  /pts exch def
  pts 0 get 0 get   pts 0 get 1 get  moveto  % the first point
  pts  1   pts length 1 sub   getinterval {  
    % [xy]
    aload pop  % x y
    lineto
  } forall % the remaining points
  pathbbox % llx lly urx ury
  4 array astore % [llx lly urx ury]
  newpath % remove the currentpath used to do the calc
  /pts discard
} def

% [[xy]] - an array of points
% return the center x y of the bounding-box of the given points.
/center-of-bbox {
  points-bbox % [llx lly urx ury]
  /box exch def 
  box 0 get  box 2 get  midpoint % x
  box 1 get  box 3 get  midpoint % x y 
  /box discard
} def


% TEXT AND FONTS -------

% new-name old-name 
% create a new font from an existing one, which uses the ISOLatin1Encoding instead of the standard encoding
% NOTE: THE ENCODING OF THIS POSTSCRIPT FILE IS ITSELF 8859-1 = ISOLatin1.
% Calling this allows (almost all) accented characters in West European languages to be treated as any other character.
% https://stackoverflow.com/questions/270672/unicode-in-postscript
/latinize {
  findfont
  dup length dict 
  begin
    % copy everything in the source font's dict except for the FID (a unique id for a font)
    { 1 index /FID ne {def}{pop pop} ifelse } forall
    /Encoding ISOLatin1Encoding def % override the encoding entry in this dict
    currentdict  % push this font-dict onto the operand stack
  end
  definefont  % internally sets a FID (font-id) for the new font
  %pop % remove the new font object from the operand stack
  1 dict begin
    /the-new-font exch def
    [(Latinized font. /FontName:) the-new-font /FontName get
    ( /FontType:) the-new-font /FontType get
    ( /FontMatrix scale-x:) the-new-font /FontMatrix get 0 get
    ] concat-strs ==
  end
} bind def

% the returned value may be a rounded value, slightly different from the expected value
% WARNING: this has only been tested with Type 1 and Type 42 fonts.
/current-font-size {
  % the font-size is part of the font-matrix
  % this depends on the fontmatrix, which in turn depends on the fonttype
  currentfont /FontMatrix get 0 get
  currentfont /FontType get 1 eq {
    % Adobe Type 1 fonts have a FontMatrix [0.001 0 0 0.001 0 0], not [1 0 0 1 0 0]
    1000 mul
  } if
  % DO ANY OTHER FONT TYPES HAVE A FONT MATRIX DIFFERENT FROM [1 0 0 1 0 0]?
} def

% str size
% set the font using an 'expected/configured' font name, and the font size
/use-another-font {
2 dict begin 
  /font-size exch def
  /font-name exch def
  % the 'my-fonts' dict is defined below
  my-fonts font-name known not {
    (DUDE, you're using an unknown font name.) ==
    font-name ==
  } if
  my-fonts font-name get 
  font-size
  selectfont
end 
} bind def

% str pct
% the font name, and the percentage of the DEFAULT font-size
% set the current font
/use-font {
  default-font-size exch pct
  use-another-font
} bind def

% str pct
% the font name, and the percentage of the CURRENT font-size
% set the current font
/r-use-font {
  current-font-size exch pct
  use-another-font
} bind def

% pct (of default font size)
% use the regular font
/REG {(regular) exch use-font} def

% pct (of default font size)
% use a numeric font
% using a monospaced font for numeric data is usually best
/NUM {(numeric) exch use-font} def
  
% pct (of default font size)
% use the italic font
/ITAL {(italic) exch use-font} def
  
% pct (of default font size)
% use the bold font
/BOLD {(bold) exch use-font} def

% str
% return the width/height (dx, dy) of the given text (in the current font)
% this is useful for centering in various ways
% https://stackoverflow.com/questions/3618194/how-to-determine-string-height-in-postscript luser droog
/text-dim {
  gsave
    0 0 moveto
    % the bounding box of the text
    false charpath flattenpath pathbbox % x0 y0 x1 y1
  grestore
  3 -1 roll sub % x0 x1 dy
  3 1 roll sub % dy -dx
  -1 mul % dy dx
  exch % dx dy
}
bind def

% str -> number
% width of the given string in the current font
/text-width {
  text-dim % dx dy
  pop % dx
} def

% str -> number
% height of the given string in the current font
/text-height {
  text-dim % dx dy
  exch pop % dy 
} def

% multiple of the height of small 'x' in the current font
/ex {
 (x) text-height mul
} def

% multiple of the height of capital 'M' in the current font
/em {
 (M) text-height mul
} def

% return a temp string of length 100, intended for use with the cvs operator
/sbuff {
  100 string
} def

% (a) (b) -> (ab)  
% concatenate two strings
% https://en.wikibooks.org/wiki/PostScript_FAQ/Programming_PostScript#How_to_concatenate_strings?
/concat-str { 
  exch dup length    
  2 index length add string    
  dup dup 4 2 roll copy length
  4 -1 roll putinterval
} bind def  

% [(tom) 1.23] ( ) -> (tom1.23)
% concat an array of N things (of any type) into one string
/concat-strs {
  2 dict begin
    /result () def
    {
      /thing exch sbuff cvs def
      /result result thing concat-str def
    } forall
    result
  end
} def

% -- DISPLAY TEXT 

% text 
% center text horizontally AND vertically at the currentpoint
% WARNING: centering text vertically can give mediocre results (variations in text ascenders etc.)
/show-ctr-xy {
  dup text-dim % text dx dy
  -2 div % text dx -dy/2
  exch % text -dy/2 dx
  -2 div exch % text -dx/2 -dy/2
  rmoveto % text
  show
} bind def

% text 
% center text horizontally at the currentpoint
/show-ctr-x {
  dup text-dim pop % text dx
  -2 div % text -dx/2
  0 rmoveto % text
  show
} bind def

% text 
% right-align text horizontally at the currentpoint
/show-right-align {
  dup text-dim pop % text dx
  -1 mul % text -dx
  0 rmoveto % text
  show
} bind def



% --- PARAGRAPHS OF TEXT ---------------

% str -> [str]
% chop a string into separate words, using a single space as delimiter.
% WARNING: this implementation is brittle:
%   - assumes no double-spaces in the text!
%   - assumes the text is trimmed!
% If an 'extra' space appears anywhere, it is returned as an item in the returned array.
/chop-text-into-pieces {
12 dict begin
  /txt exch def
  /space 32 def  % character code of the space char; 040 octal, decimal 32
  
  % count the spaces (and thus the words), in order to be able to size the array
  /num-spaces 0 def
  txt {  
    space eq {
      /num-spaces num-spaces 1 add def
    } if
  } forall % puts 0..255 integers on the stack!
  
  % record the indices of all spaces in the text
  /spaces num-spaces array def
  /idx-ch 0 def % character
  /idx-sp 0 def % space
  txt {
   space eq {
     spaces idx-sp idx-ch put
     /idx-sp idx-sp 1 add def
   } if
   /idx-ch idx-ch 1 add def
  } forall 
  
  % now I can size the result-array, and insert words into it
  /words num-spaces 1 add array def
 
  /start-word 0 def % at the beginning of the trimmed text
  /i 0 def
  % here, each space is the end of a word
  spaces {
   /idx-sp exch def
   /num-letters idx-sp start-word sub def
  
   words i 
   txt start-word num-letters getinterval  % a substring of the input
   put
  
   /start-word start-word num-letters 1 add add def 
   /i i 1 add def 
  } forall
  
  % the last word remains to be added:
  /num-letters txt length start-word sub def
  words i 
  txt start-word num-letters getinterval 
  put
 
  words % put the result-array on the stack
end
} def

% left-limit{} right-limit{} [{} {} ...] leading
% the '[{} {} ...]' are called the 'runs', stretches of text that share the exact same font.
% the limit-procs allow for non-rectangular shapes for the text.
% the limit-procs need to accept a y-value, even if they return constants.
% the caller first moves to a currentpoint, where the emission of the text begins.
% Example: 
%    { pop 10 pct-wd }  % fixed left limit
%    { 80 pct-ht gt {70 pct-wd} {100 pct-wd} ifelse } % variable right-limit
%    [{REG (She would have boiled my head, but,)} {BOLD (for reasons unexplained, she demurred.)}]
%    2 em
%    write-a-paragraph
/write-a-paragraph {
8 dict begin
  /leading exch def
  /runs exch def
  /right-edge exch def
  /left-edge exch def
  runs {
    % this is how the font is set for each run
    exec  
    % show the text one word at a time, paying attention to the left-side and right-side limits 
    /words exch chop-text-into-pieces def
    words {
      ( ) concat-str /word exch def % stick an empty space on the end of each word
      % will the emission of the next word go beyond the right-limit?
      currentpoint  /y exch def  /x exch def
      x word text-width add 
      y right-edge
      gt 
      {
        % adjust the currentpoint to the start of the next line
        % compute the new left-edge using the new y-value
        /y y leading sub def
        y left-edge y moveto
      }
      if
      word show % finally, show the word (with a trailing space)
    } forall
  } forall
end  
} def




% --- TABLES -----------

% table-dict
% Render a table as a collection of cells.
% Return xs ys on the stack, for the coords of all grid lines, in case the caller wants to render them in some custom manner.
% The origin is the top-left of the top-left cell in the table.
% Example table-dict, with two rows in the table:
% <<  
%   /row-ht 6 ex
%   /col-widths [wd 10 pct  wd 10 pct  wd 10 pct  wd 10 pct]
%   /pad 0.8 ex
%   /show-all-grid-lines? true
%   /cells [ 
%     [ {(P1)LF} {75 NUM(23:18)RT} {75 NUM(36.2)RT} {(SSE)LF} ]
%     [ {(U1)LF} {75 NUM(23:18)RT} {75 NUM(36.2)RT} {(SSE)LF} ]
%   ]
% >>
% The cells[[]] is an array of rows, top-down and left-to-right.
% Drawing to each cell is clipped to its rectangular box.
% This proc def's a number of 'sub-procs' (see implementation), some of which are referenced by cell-procs to 
% control how the cell is marked (alignment, font and so on).
/basic-table {
30 dict begin 
  % put all of the names into the new currentdict
  {def}forall
  col-widths length   cells 0 get length   ne  {
    (DISAPPOINTMENT: the first row has an unexpected number of columns.) error-message
  }if

  % the position of the top-left corner
  % if not present in the currentdict, then these are def'd as 0:
  /left is-known not { /left 0 def } if
  /top is-known not { /top 0 def } if
  
  % defs: /bottom /right /xs /ys
  % the position of the bottom-right corner is calculated from col-widths and row-ht
  % xs and ys are the locations of grid lines
  /locate-grid-lines {
    /xs col-widths length 1 add array def
    xs 0 left put 
    1  1  xs length 1 sub {
      /i exch def
      xs i    
        xs i 1 sub get         % previous
        col-widths i 1 sub get % add col-width
      add  
      put
    } for
    % do the same for ys
    /ys cells length 1 add array def 
    ys 0 top put 
    1   1   ys length 1 sub {
      /i exch def
      ys  i  
      top   row-ht i mul   sub
      put
    } for
    /bottom ys last-entry def
    /right xs last-entry def
    /i discard
  } def
  
  /draw-the-grid {
    newpath
     % vertical lines, top to bottom, then left to right
    0   1   xs length 1 sub {
     xs exch get   top   moveto
     0   bottom top sub   rlineto  % line down
    } for
    % horizontal lines, left to right, then top to bottom
    0   1   ys length 1 sub {
     ys exch get  left exch   moveto
     right left sub  0  rlineto  % line to the right
    } for
    stroke
  } def

  % i j -> x y w h  
  % translate 0-based cell indices (i,j) into the numbers describing the cell's box;
  % xy coords for the bottom left of the cell, and its width and height
  /cell-indices-to-xywh {
    2 dict begin
      /j exch def
      /i exch def
      % let's compute these critters directly on the operand stack
      % x = left + sum(col-widths 0..j-1) IF j is > 0
      left  
      j 0 gt {
        0   1  j 1 sub {
          col-widths exch get add 
        } for
      } if
      % y = top - (i+1) * row-ht
      top  i 1 add  row-ht  mul   sub 
      col-widths j get   % w
      row-ht             % h
    end
  } def
  
  % pct pct 
  % move to an arbitrary spot in the interior of a cell.
  % uses percent-width, percent-height of the cell.
  % WARNING: this is a low-level 'back-up', in case of need.
  % you'll see a different 'padding' when the column-width is different!
  /goto {
    % px py
    ht exch pct % px y
    exch % y px
    wd exch pct % y x 
    exch 
    moveto
  } def
  
  % PROCS THAT CAN BE USED TO CONTROL HOW THE CELL IS MARKED:
  
  % str 
  % left-align text within a cell
  /LF {pad pad moveto   show} def 
  
  % str 
  % right-align text within a cell
  /RT {wd pad sub   pad moveto   show-right-align} def 
  
  % str 
  % middle-x the text within a cell
  /MID {wd 50 pct   pad  moveto  show-ctr-x} def 
  
  % str
  % center-xy text within a cell
  /CTR {50 50 goto show-ctr-xy} def 

  % TRANSLATE to the middle of the cell
  /T-MID {wd 50 pct  ht 50 pct translate} def 
  
  % gray-value 0..1
  % shade the whole cell using a grayscale value
  /SHADE {
    gsave 
      setgray 
      0 0 wd ht rectfill
      0 0 wd ht rectstroke
    grestore
  } def 

  % mark all of the cells  
  /mark-cells {
    0  1   cells length 1 sub {
      % over rows
      /i exch def
      0  1   cells 0 get length 1 sub {
        /j exch def
        % over columns
        i j cell-indices-to-xywh
        4 copy  % to consume x y w h twice
        gsave 
          rectclip % clip to the cell's rect
          4 2 roll % w h x y
          translate % translate to the bottom left of the cell
          /ht exch def
          /wd exch def
          mark-the-cell % uses: i j ht wd in the currentdict
        grestore
      } for
    } for
  } def

  % mark a single cell
  %  
  % the cell consists of one thing: a proc that marks the cell!
  % this is the 'maximally flexible' design: it's not based on data+policies, but on CODE.
  % the cell 'knows' the origin is the bottom left of the cell.
  /mark-the-cell {
    % just call the proc attached to the cell! nice!
    cells i get j get exec 
  } def

  % finally, mark the table using the proc's defined above  
  locate-grid-lines
  mark-cells
  % in some cases, you won't want to draw a grid at all
  show-all-grid-lines? {
    draw-the-grid 
  } if
  % the caller may want to draw the grid in a custom manner, so 
  % we always return the locations of all possible grid lines
  xs
  ys 
end
} def


% --- DIAGRAMS -------

% margin-pct 
% centered on the page, with the given margin on all sides
% adds wd ht to the currentdict.
/set-page-work-box {
  /margin exch def
  page-width margin pct  page-height margin pct  translate % lower left
  /wd page-width  100 margin 2 mul sub pct def
  /ht page-height 100 margin 2 mul sub pct def
  /margin discard
} def

% the initial work-box is towards the left half of the page, centered vertically.
% adds wd ht to the currentdict.
/set-diagram-work-box {
  page-width  5 pct  
  page-height 43 pct  translate % lower left
  /wd page-width  50 pct def
  /ht page-height 35 pct def
} def 
 

% [llx-pct lly-pct wd-pct ht-pct]
% sets up a new work-box (wbox), using percentages of an existing work-box.
% this proc does two separate things:
%  - move the origin of coordinates to the bottom-left of the new wbox
%  - define wd and ht in the currentdict
%
% BEFORE CALLING THIS PROC, THE CALLER NEEDS TO:
% - wrap this proc in gsave-restore pair (so that old wbox-geometry can be recovered)
% - create a new currentdict, to which this proc adds new wd and ht values, 
%   in order to temporarily HIDE older values (and not overwrite them)
%
% THIS PROCEDURE USES STATE LOGIC THAT YOU NEED TO BE CAREFUL ABOUT.
% The previous context is restored by both popping the dict stack, AND using a gsave-grestore.
/set-new-work-box {
  /work-box exch def
  % a new origin of coordinates
  % this 'translate' operation uses the 'old' wd and ht
  wd work-box 0 get pct
  ht work-box 1 get pct translate
  
  % re-define the new wd and ht (higher in the dict stack) in terms of the old (lower in the dict stack)
  % note that this 'hides' the older wd and ht, it doesn't overwrite them!
  /wd wd work-box 2 get pct def
  /ht ht work-box 3 get pct def
  
  /work-box discard
} def

% blurb: show a default border using the work-box
/show-dft-blurb-border {
  newpath
  0 0 wd ht rectstroke % using the current work-box
  0 0 moveto
  5 show-currentpoint
} def

% the '/border' setting should be absent when the blurb has a default border
% this avoids needless repetition 
/show-blurb-border {
  gsave  
    /border is-known {border} {show-dft-blurb-border} ifelse  
  grestore
} def

% return a str
% either the id or the title (as override of the id)
/blurb-title {
  /title is-known {title} {id} ifelse
} def

% y-level near the top of the blurb, suitable for a blurb-title
/near-top {
  ht 1.5 em sub
} def

% the default way of showing a blurb.
% show the id (or title, if present) near the top of the blurb's work-box.
% show detail lines below. 
% all text is centered horizontally in the work-box.
% uses /id, /title, and /lines from the current (blurb) dict.
/show-dft-blurb-body {
  gsave 
    wd 2 div   near-top  moveto 
    blurb-title
    show-ctr-x
  grestore
  % put the lines below the title, in a (relatively) smaller font
  gsave 
    (italic) 80 r-use-font
      /leading 2.2 em def 
      /count 1 def
      lines {
        wd 2 div   near-top  moveto % start at the top, where the title is
        0 leading neg count mul rmoveto % move down N lines
        show-ctr-x
        /count count 1 add def
      } forall
  grestore 
  /leading discard
  /count discard
} def

/show-title-centered {
  gsave 
    wd 2 div   
    ht 2 div  moveto 
    blurb-title
    show-ctr-xy
  grestore
} def

% allow for override of a default policy
/show-blurb-body {
  gsave  
    /body is-known 
      {body} 
      {show-dft-blurb-body} 
    ifelse  
  grestore
} def

% x y [[xy]]    (or x y x y [[xy]] if there's 2 from-points)
% in this document, all blines are star-blines.
% this proc uses /from, /to from the bline's dict.
/show-dft-bline {
  star-bline
} def

% x y [[xy]]    (or x y x y [[xy]] if there's 2 from-points)
% allows for an override of a default policy for showing a bline
/show-bline {
  gsave  
    /draw is-known 
      {draw} 
      {show-dft-bline} 
    ifelse  
  grestore
} def

% id - the blurb's /id string
% find a blurb using its /id, and then put the blurb on the operand stack
/linked-blurb {  
  2 dict begin
    /target-id exch def
    /match-found false def
    diagram /blurbs get {
      dup % two blurb-dicts on the stack
      /id get target-id eq {
        % do nothing; leave the remaining blurb-dict on the stack
        /match-found true def
        exit
      }  
      {pop} % not a match; discard the remaining blurb-dict
      ifelse
    } forall
    match-found not {
      [(DUDE, YOU'RE LINKING TO AN UNKNOWN blurb-id: ) target-id] concat-strs error-message
    } if
  end
} def

% blurb
% return the (x,y) of the lower-left corner of the blurb's work-box, relative to the diagram's work-box
/lower-left {
  1 dict begin
    /blurb exch def
    wd  blurb /wbox get 0 get  pct % llx
    ht  blurb /wbox get 1 get  pct % lly
  end 
} def

% pp blurb
% pp is in the range [0,100) (perimeter point percentage)
% return the (x,y) of a blurb's perim-point, with respect to the diagram's work-box (not the blurb's work-box)
/find-perim-point {
  14 dict begin 
    /blurb exch def
    /pp exch def
    % dimensions of the blurb's work-box (wd and ht refer to the diagram's work-box)
    /width  wd  blurb /wbox get 2 get   pct def
    /height ht  blurb /wbox get 3 get   pct def
    % rescale the pp value in [0,100) to the range [0, perim-length of the blurb's work-box)
    /perim-length width height add 2 mul def 
    /pp perim-length pp 0 100 rescale def
    % (a,b,c,d) are perim-point values for the 4 corners of the blurb's work-box
    /a width 0.5 mul def
    /b width 0.5 mul height add def
    /c width 1.5 mul height add def
    /d width 1.5 mul height 2 mul add def
    
    % start with the smallest values for pp, then work your way up
    % put dx on the stack first, then dy
    % dx and dy are with respect to the lower-left of the blurb's work-box
    pp 0 ge   pp a le  and {a pp sub   0} if 
    pp a gt   pp b le  and {0    pp a sub} if  
    pp b gt   pp c le  and {pp b sub   height} if 
    pp c gt   pp d le  and {width   height pp c sub sub} if 
    pp d gt                {width pp d sub sub   0} if  
    /dy exch def
    /dx exch def
    % combine the dx dy with the position of the lower-left corner of the box, to get the final result
    blurb lower-left
    /lly exch def
    /llx exch def
    llx dx add 
    lly dy add
  end 
} def

% pp blurb
% pp is in the range [0,100) (perimeter point percentage)
% return the (x,y) (with respect to the diagram's work-box) of a lower corner (either left or right) of the id/title of the blurb.
% the y is taken from the baseline of the id/title.
% the x is found using the the width of the id/title (and the midline of the blurb's work-box).
% here, the pp value is used only to determine if the caller wants the lower-left or lower-right corner of the id/title.
% (some might choose to change that, and simply pass a boolean instead of pp.)
/find-start-end-of-text {
  8 dict begin
    /blurb exch def
    /pp exch def
    /small-gap 1.0 ex def % so that lines don't collide with the text
    % dimensions of the pathbbox of the id/title
    blurb /title known {blurb /title get} {blurb /id get} ifelse
    text-dim % dx dy
    pop
    % half-width of the text's pathbbox (plus a small gap):
    0.5 mul small-gap add /half-width exch def
    /is-left-side pp 50 le def
    /midline-x   wd   blurb /wbox get 2 get   pct   2 div def  % half the blurb-wbox width
    /midline-y   ht   blurb /wbox get 3 get   pct   1.5 em sub def % near the top of the midline
    % the desired location, wrt the lower-left corner of the blurb-wbox 
    /dx midline-x  half-width  is-left-side {neg} if  add   def
    /dy midline-y  small-gap 0.7 mul add  def 
    % finally, dx dy relative to the diagram's origin:
    blurb lower-left % llx lly
    /lly exch def
    /llx exch def
    llx dx add 
    lly dy add
  end 
} def

% x y [[xy]] 
% x and y define the location of the single from-point.
% [[xy]] is an array-of-arrays containing 1..N to-points.
% A 'star-burst' pattern from 1 point to 1..N points.
% This proc draws a straight line between a parent to 1..N children, perim-point to perim-point.
% This is the default way of drawing a bline.
% When there's only 1 to-point, then one simple line is drawn.
% When there's more than 1 to-point, then a star pattern is drawn, 
% with the star centered on the from-point.
/star-bline {
  3 1 roll % [[xy]] x y
  3 dict begin 
    /from-y exch def
    /from-x exch def
    {
      from-x from-y moveto
      /point exch def
      point 0 get  point 1 get  lineto
      stroke
    } forall % [[xy]]
  end
} def

% put the x y of the from-blurb perimeter-point(s) on the stack (for use down below)
% puts either 1 or 2 x y points on the stack
/put-from-points-on-the-stack {
  from type /dicttype eq {
    % put the 1 from-point on the stack: x y
    from /perim get   
    from /id get linked-blurb  % look up in the /blurbs array by matching on the id
    find-perim-point
  } if
  from type /arraytype eq {
    % put the 2 from-points on the stack: x y  x y
    % (for mother and father - family trees)
    from length 2 eq {  
        from {
          % <</id (Mother) /perim 0>>
          /parent exch def
          parent /perim get  
          parent /id get linked-blurb  
          find-start-end-of-text  % x y 
        } forall
        /parent discard 
      } 
      {(THE bline's 'from' ARRAY IS NOT OF LENGTH 2. EXPECTING A MOTHER-FATHER PAIR.) error-message}
    ifelse
  } if
} def

% puts [[xy]] array-of-arrays on the stack
/put-to-points-on-the-stack {
  % there are 1..N to-blurbs, each being an end-point of a given bline
  6 dict begin
    /to-xys to length array def 
    /index 0 def
    to { % an array of dicts
      % <</id (Two) /perim 50>>  example dict
      /to-dict exch def
      /to-blurb   to-dict /id get linked-blurb   def
      to-dict /perim get   to-blurb  find-perim-point  % to: x y
      /to-xy 2 array def
      to-xy astore pop
      to-xys index to-xy put
      /index index 1 add def
    } forall % to-points
    to-xys % put them on the stack
  end
} def

% show blurbs, and the blines connecting them
% uses /diagram in the currentdict
/show-diagram {
  (.....PROCESSING BLURBS...) here
  diagram /blurbs get { % an array of dicts
    % <</id (Two) /wbox [20 50 40 20] /border {} /body {}>>  example dict
    gsave % save the 'old' origin of coords
      begin % push the blurb-dict onto the dict stack - it becomes the new currentdict
        % define a new work-box (new wd and ht entries in the currentdict; a new origin of coords)
        wbox set-new-work-box
        show-blurb-border
        show-blurb-body
        id == % debugging
        % more: recursive call!
        /more is-known {
          3 dict begin gsave  % needed when you have a new work-box: holds wd, ht, diagram
            more /set-font get exec
            more /wbox get set-new-work-box
            /diagram   more /nested-diagram get  def % hide the old diagram for a while
            show-diagram % uses things in the current dict in the usual way
          grestore end
        } if
      end % pop the blurb-dict
    grestore % restore the 'old' origin of coords
  } forall
  % do the blines separately; the computed (xy) points for the perimeter-points are expressed with 
  % respect to the diagram's work-box (not a blurb's work-box)
  (.....PROCESSING BLINES...) here
  diagram /blines get { % an array of dicts
    % <</from <</id (One) /perim 0>>  /to [<</id (Two) /perim 50>>] >> example bline-dict
    gsave
      begin % push the bline-dict onto the dict stack - it becomes the new currentdict
        from /id get == % debugging
        put-from-points-on-the-stack % x y     (or x y x y if two from-points)
        put-to-points-on-the-stack % x y [[xy]]    (or x y x y [[xy]] if two from-points)
        % the following call consumes all the points on the stack
        show-bline
      end % pop the temporary dict
    grestore
  } forall
} def

% str str x-pct y-level-idx [lines]
% returns a 'standard' blurb dict.
% the strs are the blurb id and the title.
% this proc was created because of the need to make the wbox sensitive to the text inside it; it's also slightly more curt.
% the wd of its wbox is sensitive to the length of the id/title str, subject to a minimum.
% example 
%   call:   (Grandpa Oberman) () 10 4 [(1880-01-01) (1960-12-31)] std-blurb
%   output: <</id (Grandpa Oberman)  /wbox [10 20 5 10] /lines [(1880-01-01) (1960-12-31)]>>
/std-blurb {
  10 dict begin 
    /lines exch def
    /y-level-idx exch def
    /x-pct exch def
    /title exch def 
    /id exch def
    /std-blurb-wd-pct {
      [id text-width   title text-width  (2015-01-31) text-width] max
      wd div 100 mul % wd-pct
    } def
    % return [x y wd ht], a standardized wbox for the blurb
    /std-blurb-box {
      x-pct % x-pct
      94  y-level-idx 9 mul  sub % x-pct  y-pct
      std-blurb-wd-pct 5 % x-pct y-pct wd-pct ht-pct
      4 array astore %  [x-pct y-pct wd-pct ht-pct]  
    } def
    /result 4 dict def % has 3-4 keys
    result /id id put
    result /wbox std-blurb-box put
    result /lines lines put
    title length 0 gt {
      result /title title put
    } if
    result % put the dict on the operand stack
  end
} def
    
% left-parent right-parent [kid-ids] between
% the standard bline for this diagram is a horizontal family-tree bline.
% example 
%   call:   (Jay Smith) (Kitty Doe) [(Abigail) (Arnie)] 50 std-bline
%   output:
%     <<
%       /from [<</id (Jay Smith) /perim 75>> <</id (Kitty Doe) /perim 25>>]
%       /to [<</id (Abigail) /perim 50>> <</id (Arnie) /perim 50>>] 
%       /between 50
%     >>
% the output is that expected by the default drawing-procedure for blines.
/std-bline {
  7 dict begin
    /between exch def
    /kid-ids exch def
    /right-parent exch def
    /left-parent exch def
    /result 3 dict def
    result /between between put
    result /from [<</id left-parent /perim 75>> <</id right-parent /perim 25>>] put
    /children kid-ids length array def
    /count 0 def
    kid-ids {
      /kid-id exch def
      children count <</id kid-id /perim 50>>  put
      /count count 1 add def
    } forall
    result /to children put
    result  % leave the tree on the stack
  end
} def


/opening-comment {
gsave
  wd 5 pct ht 92 pct moveto 
  { pop wd 5 pct }  
  { pop wd 95 pct } 
  [
    {70 REG(A)} 
    {70 BOLD(work-box)} 
    {70 ITAL(\(wbox\))} 
    {70 REG(is a rectangular work area. It's used to guide positioning for things you're currently working on. \
A work-box is attached to both a diagram and to each of its blurbs. \
For brevity, a work-box is implemented as an array)} 
   {70 ITAL([llx lly wd ht])} 
   {70 REG(. The values are expressed as a percentage of its parent's dimensions. The origin of the CTM coords is temporarily translated to)} 
   {70 ITAL(\(llx, lly\))}
   {70 REG (. Both)} 
   {70 ITAL (wd)} 
   {70 REG (and)} 
   {70 ITAL(ht)} 
   {70 REG(are def'd into a temporary dictionary. A work-box is not a clipping region, but you can change it to one if desired.)} 
  ]
  2 em
  write-a-paragraph
grestore  
} def

% several tables in the lower right.
% purely tables, with no diagram used.
/using-dictionaries {
  gsave
    wd 66 pct ht 73 pct moveto 
    { pop wd 66 pct }  
    { pop wd 98 pct } 
    [{70 REG(Blurbs and blines in the diagram get promoted to the top of the dict stack. The dict stack has multiple)} 
     {70 ITAL(/wd)}
     {70 REG(and)} 
     {70 ITAL(/ht)}
     {70 REG (entries. Higher)}
     {70 ITAL(/wd /ht)}
     {70 REG(entries temporarily "hide" the lower ones.)}]
    2 em
    write-a-paragraph
  grestore

  gsave    
    wd 73 pct ht 25 pct translate % top left corner of the table
    <<  
     /row-ht 6 ex
     /col-widths [wd 20 pct]
     /pad 0.8 ex
     /show-all-grid-lines? true
     /cells [ 
       [ {70 REG (userdict)   CTR} ]
       [ {70 REG (globaldict) CTR} ]
       [ {70 REG (systemdict) CTR} ]
     ]
    >>
    basic-table 
    pop pop % no need for xs and ys
  grestore
  
  gsave    
    wd 73 pct ht 42 pct translate 
    <<  
     /row-ht 6 ex
     /col-widths [wd 10 pct wd 10 pct]
     /pad 0.8 ex
     /show-all-grid-lines? true
     /cells [ 
       [ {70 ITAL (key)   CTR} {70 ITAL (value)   CTR}]
       [ {(/diagram)   CTR} {(-dict-)   CTR}]
       [ {(/wd)   CTR} {(50)   CTR}]
       [ {(/ht)   CTR} {(35)   CTR}]
     ]
    >>
    basic-table pop pop 
    0 0 moveto 
    0 1 em rmoveto (diagram dictionary) show
  grestore
  
  gsave    
    wd 73 pct ht 61 pct translate 
    <<  
     /row-ht 6 ex
     /col-widths [wd 10 pct wd 10 pct]
     /pad 0.8 ex
     /show-all-grid-lines? true
     /cells [ 
       [ {70 ITAL (key)   CTR} {70 ITAL (value)   CTR}]
       [ {(/wd)   CTR} {(48)   CTR}]
       [ {(/ht)   CTR} { (10)   CTR}]
       [ {(\(other\))   CTR} {(...)   CTR}]
     ]
    >>
    basic-table pop pop 
    0 0 moveto 
    0 1 em rmoveto (blurb dictionary) show
  grestore
} def

% a box with 0, 25, 50, 75 param-points indicated (very hard-coded!)
/show-param-point-explanation {
  gsave
  2 dict begin
    wd 15 pct
    ht 7 pct translate
    /width  wd 30 pct def
    /height ht 10 pct def
    0 0 width height rectstroke
    % dots on the circumference, with corresponding values of the perim-parameter
    newpath width 2 div 0      2 0 360 arc gsave fill grestore (0) show 
    newpath 0 height 2 div     2 0 360 arc gsave fill grestore (25) show 
    newpath width 2 div height 2 0 360 arc gsave fill grestore (50) show 
    newpath width height 2 div 2 0 360 arc gsave fill grestore (75) show 
    % a nominal bline line, from the 0-point
    width 0.85 mul height 0.25 mul neg moveto   (bline) show
    newpath
    0.5 setcolor
    width 2 div 0 moveto
    width 1.1 mul   height -0.5 mul lineto stroke
  end
  grestore  
  
  gsave
    wd 5 pct ht 22 pct moveto 
    { pop wd 5 pct }  
    { pop wd 60 pct } 
    [
      {70 REG(Blines are implemented with)}
      {70 ITAL(perimeter-parameters)}
      {70 REG(in the range [0,100]. The bottom-center corresponds to 0.)}
    ]
    2 em
    write-a-paragraph
  grestore
  
} def

/data-structures {
  gsave    
    wd 0 pct ht 38 pct translate 
    <<  
     /row-ht 5 ex
     /col-widths [wd 9 pct wd 60 pct]
     /pad 0.6 ex
     /show-all-grid-lines? false
     /cells [ 
       [ {70 BOLD(diagram:)  RT} {70 ITAL (<</blurbs [...] /blines [...]>>)   LF}]
       [ {70 BOLD(blurb:)    RT} {70 ITAL (<</id (blurb1) /wbox [15 80 48 10] ...>>)   LF}]
       [ {70 BOLD(bline:)    RT} {70 ITAL (<</from  <</id (blurb1) /perim  0>> /to [<</id (blurb2) /perim 50>>] >>)   LF}]
     ]
    >>
    basic-table pop pop 
} def

/large-title {
  gsave
  (bold) 125 use-font 
  wd 50 pct ht 98 pct moveto
  (Box Diagrams - Main Ideas) show-ctr-x
  grestore
} def


%%EndProlog 

%%BeginSetup               
  % modify items in the graphics state that won't be changed by initgraphics/showpage/erasepage
  % often: userdict and setpagedevice 

   % The original PDF standard allowed for extremely large PDFs, but later standards limit the size to 200 inches square.
   % If you're not intending to print the output PDF, then you can use a smaller size.
   % WARNING: These settings are repeated in the Document Structuring Convention comments near the top of this file (DocumentMedia, BoundingBox).
  /page-width  8.5 72 mul def
  /page-height 11 72 mul def % absolute values

  % the tolerance is 5 units in each dimension
  % the order of the width/height actually doesn't matter
  <</PageSize [page-width  page-height]>> setpagedevice  
  
  % ALWAYS EMBED FONTS.
  % This setting means no fonts will be prevented by GS from being embedded in the final PDF.
  % https://stackoverflow.com/questions/79386904/postscript-text-outline-doesnt-match-the-text
  << /NeverEmbed [ ] >> setdistillerparams
  
  true setstrokeadjust  % minimizes off-by-one-pixel line issues

  % CORE TYPEFACES used in the Document
  % these are all 'latinized': they use the ISOLatin1 encoding (same as 8859-1), instead of the default encoding
  % WARNING: YOUR POSTCRIPT FILES MUST BE ENCODED IN 8859-1 AS WELL. 
  % You can use Notepad++ to do conversions of the encoding of a file.
  
  % Courier: an Adobe Type 1 font, with FontMatrix [0.001 0 0 0.001 0 0]
  %/MyRegular /Courier latinize
  %/MyItalic /Courier-Oblique latinize
  %/MyBold /Courier-Bold latinize
  
  % Helvetica: an Adobe Type 1 font, with FontMatrix [0.001 0 0 0.001 0 0]
  /MyRegular /Helvetica latinize
  /MyItalic /Helvetica-Oblique latinize
  /MyBold /Helvetica-Bold latinize

  % Georgia (on a Windows 11 PC): an Adobe Type 42 font, with FontMatrix [1 0 0 1 0 0]
  %/MyRegular /Georgia        latinize
  %/MyItalic  /Georgia-Italic latinize
  %/MyBold    /Georgia-Bold   latinize
  
  /MyNumeric /Consolas   latinize
  
  /my-fonts <<
    (regular) /MyRegular
    (italic)  /MyItalic
    (bold)    /MyBold
    (numeric) /MyNumeric
  >> def
  
  % changing this value will do a proportiate change to all of your fonts.
  % HOWEVER, you'll likely have layout/postion adjustments to make if you do that.
  /default-font-size page-height 2 pct def  

%%EndSetup 

%%Page: 1 1
%%BeginPageSetup 
 /pgsave save def     
%%EndPageSetup

  (Starting: page 1 of 1.) here
  
  % start with a default font
  (regular) 60 use-font 
  
  1 setlinejoin % less jagged
  2 setlinecap % less jagged

  3 dict begin 
    gsave 
      (Setting intial work-box as portrait.) here
      set-diagram-work-box
      gsave 
        0 0 moveto
        10 show-currentpoint
        [3] 0 setdash
        0 0 wd ht rectstroke 
      grestore
      /diagram  << 
        /blurbs [
          << /id (blurb1) /wbox [15 80 48 10] /lines [(<</id (blurb1) /wbox \[15 80 48 10\]...>>)] >>
          << /id (blurb2) /wbox [42 55 48 10] /lines [(<</id (blurb2) /wbox \[42 55 48 10\]...>>)] >>
          << /id (blurb3) /wbox [30 30 48 10] /lines [(<</id (blurb3) /wbox \[30 30 48 10\]...>>)] >>
          << /id (This diagram has 3 blurbs and 2 blines.) /wbox [10 10 80 10] /lines [] /body {show-title-centered} /border {}>>
          << /id (Blurbs can contain a nested diagram.) /wbox [10 5 80 10] /lines [] /body {show-title-centered} /border {}>>
          << /id(bline1) /title(bline) /wbox [25 42 80 10] /lines [] /body {show-title-centered} /border {}>>
          << /id(bline2) /title(bline) /wbox [20 68 80 10] /lines [] /body {show-title-centered} /border {}>>
        ] 
        /blines [
          << /from  <</id (blurb1) /perim  0>>  /to   [<</id (blurb2) /perim 50>>]   >> 
          << /from  <</id (blurb2) /perim  0>>  /to   [<</id (blurb3) /perim 50>>]   >> 
        ] 
      >> def
      show-diagram
    grestore
  end 

  3 dict begin 
    3 set-page-work-box 
    large-title
    opening-comment
    using-dictionaries
    show-param-point-explanation
    data-structures
  end

  count 0 gt {
   % this indicates a problem: you've left something on the stack at the end of the program
   (---- TO ERR IS HUMAN; THY STACK IS NOT EMPTY. THY 'RESTORE' OPERATION MAY FAIL...: )  dump-stack
  } if
  
  (Ending: page 1 of 1.) here

pgsave restore
showpage
%%PageTrailer
%%Trailer    
%%EOF 
