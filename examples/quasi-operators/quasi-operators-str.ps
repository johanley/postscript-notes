%!PS-Adobe-3.0
%%Title: Quasi-Operators for Strings
%%Version: 1.0
%%Creator: John O'Hanley
%%CreationDate: 2026-02-18
%%LanguageLevel: 3.0
%%DocumentMedia: Plain 612.0 792.0 60 white ()
%%DocumentNeededResources: font Helvetica
%%BoundingBox: 0 0 612 792
%%Orientation: Portrait 
%%Pages: 1
%%EndComments 

%%BeginDefaults 
%%EndDefaults

%%BeginProlog


% SIMPLE PROC'S FOR STRINGS THAT FEEL MUCH LIKE BUILT-IN OPERATORS.
% (This is of course a matter of taste.)

% str str -> str
% concatenate exactly two strings together
/str-concat {
  [/a /b] {
    /result a length b length  add string def
    result 0         a putinterval 
    result a length  b putinterval
    result % leave it on the stack
  } def-tmp
} bind def

% [any] -> str
% convert items to strings using cvs (if necessary), and concatenate the strings together.
% any items converted using cvs here must have a max string-length of 500.
/any-concat {
  [/anys] {
    /result () def 
    anys {
      dup 
      type /stringtype ne {
        % a cvs conversion is needed
        500 string cvs 
      } if
      result exch str-concat
      /result defi
    } forall
    result % leave it on the stack
  } def-tmp
} bind def

% return an array of character codes (ints), corresponding to whitespace characters.
% WARNING: includes 240, the non-breaking space in the CE and ISOLatin1 encoding. 
/str-whitespace {
  % Red Book 3rd ed. page 27 and page 783 
  % I'm including 240 here because of the prevalence of ISOLatin1.  
  [
    0 % null
    9 % tab
    10 % line feed
    12 % form feed
    13 % carriage return
    32 % space (the final frontier...)
    240 % non-breaking space, in the CE and ISOLatin1 encoding 
  ] % character codes 
} bind def

% return an array of character codes (ints), corresponding to whitespace characters.
% WARNING: includes 240, the non-breaking space in the CE and ISOLatin1 encoding. 
/str-newline {
  % Red Book 3rd ed. page 27 and page 783 
  [
    10 % line feed
    13 % carriage return
  ] % character codes 
} bind def


% char code (int) -> bool
% return true iff the character code corresponds to a whitespace character code.
/str-is-cc-whitespace? { 
  [/cc] {
    false % default result
    str-whitespace {
      cc eq {
        not exit % override default
      } if
    } forall
  } def-tmp
} bind def

% char code (int) -> bool
% return true iff the character code corresponds to a newline character code.
% TODO CONSOLIDATE WITH THE WHITESPACE VERSION OF THIS PROC.
/str-is-cc-newline? { 
  [/cc] {
    false % default result
    str-newline {
      cc eq {
        not exit % override default
      } if
    } forall
  } def-tmp
} bind def


% str -> bool
% return true iff all the character codes in the given string are white-space character codes.
/str-is-whitespace? {
  % scan each element of the string
  true exch % default return value
  { % scan the str
    % int 0..255
    str-is-cc-whitespace? not {not exit} if 
  } forall
} def

% str -> str
% remove any whitespace from the start and end of a string.
/str-trim {
  [/str] {
    /first -1 def % idx of first non-space
    /last -1 def % idx of last non-space
    % move forward from the start, to find the first non-whitespace:
    0 1 str length 1 sub {
      /idx defi
      str idx 1 getinterval  
      str-is-whitespace? not {
        /first idx def
        exit
      } if
    } for
    % move backwards from the end, to find the last non-whitespace:
    str length 1 sub -1 0 {
      /idx defi
      str idx 1 getinterval  
      str-is-whitespace? not {
        /last idx def
        exit
      } if
    } for
    % return a substring of the given string
    first -1 eq 
      {()}
      { 
        str first
        last first sub 1 add
        getinterval 
      }
    ifelse
  } def-tmp
} bind def

% str [a b] delta -> str
% helper proc for implementing uppercase and lowercase for ISOLatin1.
% return a str with the same length, but re-map (linearly) character codes from range [a b] to range [a+delta b+delta].
/str-swap-char-code-range {
  [/str /range /delta] {
    range length 2 ne {
      (DUDE, passed array must have have length 2.) ==
    } if 
    /result str length string def
    /idx 0 def
    str {
      % int 0..255
      /cc defi % character code
      cc  range first  ge     
      cc  range last   le and {
        /cc cc delta add def
      } if
      % put the cc into the result
      result idx cc put
      /idx idx 1 add def
    } forall
    result
  } def-tmp
} bind def

% str -> str
% return a lower-case string. 
% WARNING: THIS APPLIES TO ISOLatin1 ONLY.
/str-lower-case {
  [/str] {
    /result str    [65   90] 32 str-swap-char-code-range def  % A..Z maps to a..z  101..132 octal
    /result result [192 221] 32 str-swap-char-code-range def  % accented chars     300..335 octal
    result
  } def-tmp
} bind def

% str -> str
% return an upper-case string. 
% WARNING: THIS APPLIES TO ISOLatin1 ONLY.
/str-upper-case {
  [/str] {
    /result str    [ 97 122] -32 str-swap-char-code-range def  % a..z maps to A..Z  141..172 octal
    /result result [224 253] -32 str-swap-char-code-range def  % accented chars     340..375 octal
    result
  } def-tmp
} bind def

% str-a str-b -> bool
% return true iff str-a starts with str-b
% return false if a or b is an empty string
/str-starts-with? {
  [/a /b] {
    false % default
    a length 0 gt  b length 0 gt  and {
      a 0 b length getinterval 
      b eq {
        not % reverse the default
      } if
    } if 
  } def-tmp
} bind def

% str-a str-b -> bool
% return true iff str-a ends with str-b
% return false if a or b is an empty string
/str-ends-with? {
  [/a /b] {
    false % default
    a length 0 gt  b length 0 gt  and {
      a 
      a length b length  sub 
      b length 
      getinterval 
      b eq {
        not % reverse the default
      } if
    } if
  } def-tmp
} bind def

% str-a str-b -> bool
% return true iff str-a contains str-b
/str-contains? {
  search 
  dup
  {4 1 roll pop pop pop}
  {exch pop} 
  ifelse  
} bind def

% str-a str-b str-c -> str num-replacements-made
% the returned string has each occurrence of str-b replaced with str-c.
/str-replace {
  [/a /b /c] {
    /result () def 
    /result-count 0 def
    /target a def % to start with, the target of the search operation
    {
      target b search {
        /result-count result-count 1 add def
        % post match pre
        % found b in the target, so update the result
        result exch str-concat % result + pre
        /result defi 
        pop % discard the match
        /result result c str-concat def % result + c
        % keep searching on a new target (the post/remainder)
        /target defi
      } 
      {
        % b not found in the target
        result exch str-concat 
        /result defi
        exit % the loop
      }
      ifelse
    } loop % until 'exit' is invoked
    result result-count % left on the stack
  } def-tmp
} bind def

% str cc-str -> int
% count the number of times a character code (cc) appears in a string
% the character code is passed as a string having length 1.
/str-cc-count {
  [/str /cc] {
    cc length 1 ne {(str-cc-count: The target str should have length 1.)} if
    /result 0 def
    /target cc 0 get def
    str {
      % int 0..255
      target eq { 
        /result result 1 add def 
      } if
    } forall
    result
  } def-tmp
} bind def

% str -> int
% count the number of lines in the given string.
% ()  has 0 lines.
% ( ) has 1 line.
% (Bob) has 1 line.
% Lines can be empty or non-empty.
/str-line-count {
  dup length 0 eq {
    pop 0
  } { 
    str-coerce-newlines-to-n 
    (\n) str-cc-count 1 add
  } ifelse
} bind def

% str -> str
% ensure all newline characters in a given string are coerced to '\n'
%   Windows:  (\r\n)
%   Nix/Mac:  (\n)
%   Old Mac:  (\r)
/str-coerce-newlines-to-n {
  % the order is important
  % this impl is brittle; it depends on quirks in the data
  (\r\n) (\n) str-replace pop
  (\r)   (\n) str-replace pop 
} bind def

% str -> [str]
% chop a string into an array of lines, separating on newline characters.
% the lines can contain an empty string.
/str-lines {
  [/str] {
    /str str str-coerce-newlines-to-n def
    /cut 0 def % where to start/cut for a line 
    /idx 0 def  % an index into the str
    /lines str str-line-count array def % the result
    /lines-idx 0 def
    /found-line {
      lines 
      lines-idx 
      str cut  idx cut sub   getinterval
      put
      /lines-idx lines-idx 1 add def
      /cut idx 1 add def
    } def
    /NL (\n) 0 get def
    str {
      % int 0..255
      NL eq {
        found-line 
      } if
      /idx idx 1 add def
    } forall
    % remainders at the end; these cases are mutually exclusive
    cut  str length 1 sub  le {
      found-line
    } if
    str (\n) str-ends-with? { 
      found-line 
    } if
    lines
  } def-tmp
} bind def

% a b -> int 
% return 0 iff strings a and b are 'eq'-equal.
% return -1 if as is before b, +1 if a is after b.
% the comparison is a pair-wise comparison of character codes.
/str-compare {
  [/a /b] {
    0 % default
    a b ne {
      0   1  a length b length min 1 sub {
        /i defi
        a i get  b i get lt {
          -1 add exit
        } if
        a i get  b i get gt {
          1 add exit 
        } if
      } for
      dup 0 eq {
        a length b length lt 
          {-1 add}
          { 1 add} 
        ifelse
      } if % still no decision after pair-wise comparisons
    } if % not equal
  } def-tmp
} bind def

% str proc -> int
% return the number of parts that result after splitting a string on certain character codes.
% proc takes a character code, and returns a 'true' iff the character is a 'splitting' char.
/str-num-parts {
  [/is-split-char] {
    /curr false def % whether a char-code is 'kept' or not, as determined by the proc
    /prev false def
    0 % default result
    exch
    { % 0..255
      is-split-char not /curr defi
      % only one transition is detected:
      curr prev not and {1 add} if
      /prev curr def
    } forall
  } def-tmp
} bind def

% str -> int
/str-num-words {
  {str-is-cc-whitespace?} 
  str-num-parts
} bind def

% run unit tests for the string procs in this file.
% return the num tests, and the num fails.
/str-run-unit-tests {
  [
    [ [(abc)] {str-is-whitespace?} [false] ]
    [ [(abc )] {str-is-whitespace?} [false] ]
    
    [[(abc)] {str-is-whitespace?} [false] ]
    [[(abc )] {str-is-whitespace?} [false]   ] 
    [[( abc )] {str-is-whitespace?} [false]   ] 
    [[()] {str-is-whitespace?} [true]   ] 
    [[( )] {str-is-whitespace?} [true]   ] 
    [[(  )] {str-is-whitespace?} [true]   ] 
    [[(\r\n\t  )] {str-is-whitespace?} [true]   ] 
    % using octal literals
    [[(\000)] {str-is-whitespace?} [true]   ] 
    [[(\011)] {str-is-whitespace?} [true]   ] 
    [[(\012)] {str-is-whitespace?} [true]   ] 
    [[(\014)] {str-is-whitespace?} [true]   ] 
    [[(\015)] {str-is-whitespace?} [true]   ] 
    [[(\040)] {str-is-whitespace?} [true]   ] 
    [[(\000\011\012\014\015\040)] {str-is-whitespace?} [true]   ] 
    [[(\000\011\012\014\015\040 )] {str-is-whitespace?} [true]   ] 
    [[(\000\011\012\014\015\040 A)] {str-is-whitespace?} [false]   ] 

    [[(abc)] {str-trim} [(abc)]  ] 
    [[( DEF)] {str-trim} [(DEF)]  ] 
    [[(GHI )] {str-trim} [(GHI)]  ] 
    [[( pqr )] {str-trim} [(pqr)]  ] 
    [[(  st )] {str-trim} [(st)]  ] 
    [[(  xyz       )] {str-trim} [(xyz)]  ] 
    [[()] {str-trim} [()]  ] 
    [[(\r\n\t)] {str-trim} [()]  ] 

    [[(Bob Marley and the Wailers)] {str-upper-case} [(BOB MARLEY AND THE WAILERS)]  ] 
    [[(123 456 7890 +-/*!@#$%^&*\(\))] {str-upper-case} [(123 456 7890 +-/*!@#$%^&*\(\))]  ] 
    
    [[(Bob Marley and the Wailers)] {str-lower-case} [(bob marley and the wailers)]  ] 
    [[(123 456 7890 +-/*!@#$%^&*\(\))] {str-lower-case} [(123 456 7890 +-/*!@#$%^&*\(\))]  ] 

    [[(Bob Marley) (Bob)] {str-starts-with?} [true]  ] 
    [[(Bob Marley) (Bob )] {str-starts-with?} [true]  ] 
    [[(Bob Marley) (Bob M)] {str-starts-with?} [true]  ] 
    [[(Bob Marley) (b)] {str-starts-with?} [false]  ] 
    [[(Bob Marley) (bob)] {str-starts-with?} [false]  ] 
    [[(Bob Marley) (bob marley)] {str-starts-with?} [false]  ] 
    [[(Bob) ()] {str-starts-with?} [false]  ] 
    [[() (Bob)] {str-starts-with?} [false]  ] 
    
    [[(Bob Marley) (y)] {str-ends-with?} [true]  ] 
    [[(Bob Marley) (Marley)] {str-ends-with?} [true]  ] 
    [[(Bob Marley) ( Marley)] {str-ends-with?} [true]  ] 
    [[(Bob Marley) (marley)] {str-ends-with?} [false]  ] 

    [[(Bob Marley) (Bob)] {str-contains?} [true]  ] 
    [[(Bob Marley) (Bob Marley)] {str-contains?} [true]  ] 
    [[(Bob Marley) ( Mar)] {str-contains?} [true]  ] 
    [[(Bob Marley) ( Marley)] {str-contains?} [true]  ] 
    [[(Bob Marley) (y)] {str-contains?} [true]  ] 
    [[(Bob Marley) (BOB)] {str-contains?} [false]  ] 
    [[(Bob Marley) (m)] {str-contains?} [false]  ] 
    [[(Bob Marley) ( Bob Marley)] {str-contains?} [false]  ] 
    [[(Bob Marley) (Bob Marley )] {str-contains?} [false]  ] 

    [[(Bob Marley) (Bob) (Ziggy)] {str-replace} [(Ziggy Marley) 1]  ] 
    [[(This is a Stanley Kubrick Movie) (Stanley Kubrick) (Steven Speilberg)] {str-replace} [(This is a Steven Speilberg Movie) 1]  ] 
    [[(This is a Stanley Kubrick Movie) (S) (s)] {str-replace} [(This is a stanley Kubrick Movie) 1]  ] 
    [[(This is a Stanley Kubrick Movie) (X) (s)] {str-replace} [(This is a Stanley Kubrick Movie) 0]  ] 
    [[(This is the first. This is the second. This is the third.) (the) (THE)] {str-replace} [(This is THE first. This is THE second. This is THE third.) 3]  ] 

    [[(Bob Marley) ( )] {str-cc-count} [1]  ] 
    [[(Bob Marley) (B)] {str-cc-count} [1]  ] 
    [[(Bob Marley) (y)] {str-cc-count} [1]  ] 
    [[(Bob Marley and the Wailers) ( )] {str-cc-count} [4]  ] 
    [[(Bob Marley and the Wailers\nRastaman Vibration) (\n)] {str-cc-count} [1]  ] 
    [[(Bob Marley and the Wailers
    Rastaman Vibration) (\n)] {str-cc-count} [1]  ] 
    [[(Bob Marley) (X)] {str-cc-count} [0]  ] 

    [[(Bob Marley)] {str-line-count} [1]  ] 
    [[()] {str-line-count} [0]  ]    
    [[( )] {str-line-count} [1]  ] 
    [[(abc \n def)] {str-line-count} [2]  ] 
    [[(abc 
    def)] {str-line-count} [2]  ] 

    [[(Abc)] {str-lines} [[(Abc)]]  ] 
    [[(One \n Two \n Three)] {str-lines} [[(One ) ( Two ) ( Three)]]  ] 
    [[()] {str-lines} [[]]  ] 
    [[(  )] {str-lines} [[(  )]]  ] 
    [[(\n)] {str-lines} [[() ()]]  ] 
    [[(Abc\n)] {str-lines} [[(Abc) ()]]  ] 
    [[(Abc\n\n)] {str-lines} [[(Abc) () ()]]  ] 
    [[(p \n q \n r)] {str-lines} [[(p ) ( q ) ( r)]]  ] 
    
    [[(abc) (abc)] {str-compare} [0]   ] 
    [[(abc) (def)] {str-compare} [-1]  ] 
    [[(def) (abc)] {str-compare} [1]   ]  
    [[(abc) (abcdef)] {str-compare} [-1]   ] 
    [[(abcdef) (abc)] {str-compare} [1]   ] 
    [[() ()] {str-compare} [0]   ] 
    [[( ) ( )] {str-compare} [0]   ] 
    [[(abc\n) (abc\n)] {str-compare} [0]   ] 
    [[(\r\n\t) (\r\n\t)] {str-compare} [0]   ] 
    [[(\r\n\t) (\r\n\t )] {str-compare} [-1]   ] 
    [[(123) (456)] {str-compare} [-1]   ] 
    [[(4) (5)] {str-compare} [-1]   ] 
    [[(5) (4)] {str-compare} [1]   ] 
    [[(3.14) (3.14)] {str-compare} [0]   ] 
     
    [[()] {str-num-words} [0]   ] 
    [[( )] {str-num-words} [0]   ] 
    [[(   )] {str-num-words} [0]   ] 
    [[(\012)] {str-num-words} [0]   ] 
    [[(\012\015)] {str-num-words} [0]   ] 
    [[(abc)] {str-num-words} [1]   ] 
    [[(abc def)] {str-num-words} [2]   ] 
    [[(abc\tdef)] {str-num-words} [2]   ] 
    [[(abc\ndef)] {str-num-words} [2]   ] 
    [[(abc\t\r\n def)] {str-num-words} [2]   ] 
    [[(abc def xyz)] {str-num-words} [3]   ] 
    [[(   abc   def   xyz  \t\n)] {str-num-words} [3]   ] 
  ]
  test-eq-suite
} def

% [input(s)] {the-proc} [expected-output(s)] -> bool
% returns false iff the test fails.
% a test fails iff the target-proc's actual output is not the expected-output.
% uses 'eq' to compare values; for arrays, eq-arrays? is used.
% when calling this proc, the stack has to have exactly 3 items.
% TODO: DEFINE A 'DEEP-EQUALS' FOR ALL KINDS OF OBJECTS (RECURSIVE - ARRAYS OF ARRAYS, AND WHATNOT)
/test-eq {
  count 3 gt {
    % just in case of an egregious error in the caller
    (Aborting. A unit-test is being run with a larger-than-expected stack.) ==
    false 
  }
  { 
    [/inputs /the-target-proc /exp-outputs] {
      true % default success
      inputs aload pop the-target-proc % true actual-outputs
      % try to match the n expected-outputs to the n corresponding actual-outputs on the stack
      count 1 sub /num-actual-outputs defi
      num-actual-outputs  exp-outputs length  ne {
        % the number of actual-outputs is unexpected
        num-actual-outputs {pop} repeat % clear the actual-outputs
        not % fail
      } 
      { % cycle backwards, compare expected-output to actual-output
        exp-outputs length 1 sub  -1  0 {
          exp-outputs exch get 
          dup type /arraytype eq
           {eq-arrays? not {not exit} if} 
           {ne             {not exit} if} 
          ifelse 
        } for
      }
      ifelse 
    } def-tmp
  } ifelse
} bind def

% [  [[inputs] {target-proc} [expected-outputs]]  ] -> num-tests num-fails
% run a group of unit tests as a unit.
% each test is run with test-eq.
/test-eq-suite {
  /num-tests 0 def
  /num-fails 0 def
  { % [[inputs] {target-proc} [expected-outputs]]
    /num-tests num-tests 1 add def
    aload pop % [inputs] {target-proc} [expected-outputs]
    test-eq not {/num-fails num-fails 1 add def} if
  } forall
  num-tests
  num-fails
} bind def



% array
% return the last item in an array
/last {
  dup length 1 sub  get
} bind def

% array
% return the first item in an array
/first {
  0 get
} bind def

% key
% 'un-def' the given key from the currentdict
% if you only have 1-2 new items def'd in a proc, then instead of using a begin-end temporary dict,
% you might choose to just use the currentdict, and remove (discard) the items at the end of the proc.
/discard {
 currentdict exch undef  
} bind def

% any /name
% def's /name with any, with any being the next item on the stack
%
% any1 any2 [/name1 /name2]
% def's /name_i with any_i, with any_N being the next N items on the stack
%
% an "inverted" version of 'def', with the args reversed.
% adds items to the current-dict
% this replaces the very common :
%   /a exch def
% with the slightly more curt :
%   /a defi
% 
% If you need to def multiple items, then passing an array of names provides more savings:
%   [/a /b /c] defi
% Inspired by code seen here: https://github.com/denismm/dmmlib
/defi {
  count 0 eq {
    (DUDE, the operand stack is empty. Can't def anything.) ==
  } if
  dup
  type /arraytype eq
  {
    % any1 any2 [/name1 /name2]
    % this silly random name avoids collisions with the currentdict (can't use a temp dict here)
    /names-axnlywdthdenoonpartst exch def % any1 any2
    % iterate backwards over the names-array, in order to match with the 'any_i' items
    names-axnlywdthdenoonpartst length 1 sub  -1   0 {
      names-axnlywdthdenoonpartst exch get exch def
    } for
    /names-axnlywdthdenoonpartst discard
  }
  {
    % any /name 
    exch def
  }
  ifelse
} bind def

% [/name] {...} 
% use a temp dictionary for the duration of the given proc.
% populate the temp dict using the given name-array, by consuming values already on the operand stack (below the name-array).
% this encapsulates a common pattern for the body of many procs:
%  10 dict begin 
%     def'ing 1..N items from the operand stack.  
%  end
% the given name-array needs to have at least 1 item.
% inside the proc, the caller can add more items to the temp dict created internally by this proc (in Language Level 2 or greater).
/def-tmp {
  exch dup length dict begin 
    exch        % [/name] {...}
    /proc defi  % [/name] 
    defi
    proc % this exec's the proc
  end
} def

% [] [] -> bool
% return true iff the arrays have the same length, and the elements at the same 
% index are pair-wise equal using 'eq'.
/eq-arrays? {
  [/a /b] {
    true % default
    a type /arraytype eq   b type /arraytype eq  and {
      a length b length eq {
        0  1  a length 1 sub {
          dup  % i i 
          a exch get % i a[i]
          exch % a[i] i
          b exch get % a[i] b[i]
          ne {not exit} if
        } for
      } 
      {not} % the same length
      ifelse 
    } 
    {not} % both array-type objects
    ifelse
  } def-tmp
} def


%%EndProlog

%%BeginSetup 
%%EndSetup 

%%Page: 1 1
%%BeginPageSetup 
 /pgsave save def     
%%EndPageSetup

  [(Executed using: ) product ( ) revision ( level ) languagelevel] any-concat ==
  
  /Helvetica 24 selectfont 
  
  100 700 moveto
  (abc) (def) str-concat show
  100 650 moveto
  [(John) (Smith)] any-concat show
  100 600 moveto
  [(Abe) 3.14159] any-concat show
  100 550 moveto
  [(pi = ) 3.14 (, e = ) 2.79] any-concat show
  
  str-run-unit-tests
  [/tests /fails] defi
  [(Num tests: ) tests ( Num fails: ) fails] any-concat ==

pgsave restore
showpage
%%PageTrailer
%%Trailer    
%%EOF 