%!PS-Adobe-3.0
%%Title: Quasi-Operators
%%Version: 1.0
%%Creator: John O'Hanley
%%CreationDate: 2026-02-14
%%LanguageLevel: 3.0
%%DocumentMedia: Plain 612.0 792.0 60 white ()
%%DocumentNeededResources: font Helvetica
%%BoundingBox: 0 0 612 792
%%Orientation: Portrait 
%%Pages: 1
%%EndComments 

%%BeginDefaults 
%%EndDefaults

%%BeginProlog


% SIMPLE PROC'S THAT FEEL MUCH LIKE BUILT-IN OPERATORS.
% This is of course a matter of taste.
% Your own needs and sense of taste will determine what proc's you would categorize as such.
% Some procs are elementary; they simply read better at the point of call.


% key 
% return true iff the key is in the currentdict
/is-known {
 currentdict exch known
} bind def

% key
% 'un-def' the given key from the currentdict
% if you only have 1-2 new items def'd in a proc, then instead of using a begin-end temporary dict,
% you might choose to just use the currentdict, and remove (discard) the items at the end of the proc.
/discard {
 currentdict exch undef  
} bind def

% any /name
% def's /name with any, with any being the next item on the stack
%
% any1 any2 [/name1 /name2]
% def's /name_i with any_i, with any_N being the next N items on the stack
%
% an "inverted" version of 'def', with the args reversed.
% adds items to the current-dict
% this replaces the very common :
%   /a exch def
% with the slightly more curt :
%   /a defi
% 
% If you need to def multiple items, then passing an array of names provides more savings:
%   [/a /b /c] defi
% Inspired by code seen here: https://github.com/denismm/dmmlib
/defi {
  count 0 eq {
    (DUDE, the operand stack is empty. Can't def anything.) ==
  } if
  dup
  type /arraytype eq
  {
    % any1 any2 [/name1 /name2]
    % this silly random name avoids collisions with the currentdict (can't use a temp dict here)
    /names-axnlywdthdenoonpartst exch def % any1 any2
    % iterate backwards over the names-array, in order to match with the 'any_i' items
    names-axnlywdthdenoonpartst length 1 sub  -1   0 {
      names-axnlywdthdenoonpartst exch get exch def
    } for
    /names-axnlywdthdenoonpartst discard
  }
  {
    % any /name 
    exch def
  }
  ifelse
} bind def

% [/name] {...} 
% use a temp dictionary for the duration of the given proc.
% populate the temp dict using the given name-array, by consuming values already on the operand stack (below the name-array).
% this encapsulates a common pattern for the body of many procs:
%  10 dict begin 
%     def'ing 1..N items from the operand stack.  
%  end
% the given name-array needs to have at least 1 item.
% inside the proc, the caller can add more items to the temp dict created internally by this proc (in Language Level 2 or greater).
/def-tmp {
  exch dup length dict begin 
    exch        % [/name] {...}
    /proc defi  % [/name] 
    defi
    proc % this exec's the proc
  end
} def

% pass two numbers; a value and a percent
% example '70 15 pct' is 15% of 70
% note that 15% is represented here as '15', not as '0.15'
% this simple proc is very widely used!
/pct {
 0.01 mul mul
} bind def

% array
% return the last item in an array
/last {
  dup length 1 sub  get
} bind def

% array
% return the first item in an array
/first {
  0 get
} bind def

% [] [] -> bool
% return true iff the arrays have the same length, and the elements at the same 
% index are pair-wise equal using 'eq'.
/eq-arrays {
  [/a /b] {
    true % default
    a type /arraytype eq   b type /arraytype eq  and {
      a length b length eq {
        0  1  a length 1 sub {
          dup  % i i 
          a exch get % i a[i]
          exch % a[i] i
          b exch get % a[i] b[i]
          ne {not exit} if  % not pair-wise equal
        } for
      } 
      {not} % the same length
      ifelse 
    } 
    {not} % both array-type objects
    ifelse
  } def-tmp
} def

% [input(s)] {the-proc} [expected-output(s)] -> bool
% returns false iff the test fails (the target-proc's actual output is not the expected-output).
% uses 'eq' to compare.
% simple test harness.
/test-eq {
  [/inputs /the-proc /exp-outputs] {
    true % default success
    inputs aload pop the-proc
    % try to match n outputs to the top n things on the stack 
    count exp-outputs length lt {
      not % fails
    } 
    { % cycle backwards, compare expected-output to stack contents
      exp-outputs length 1 sub  -1  0 {
        exp-outputs exch get 
        
        dup type /arraytype eq
         {eq-arrays not {not exit} if} 
         {ne {not exit} if} 
        ifelse 
        
        %ne {not exit} if
      } for
    }
    ifelse 
  } def-tmp
} bind def

%%EndProlog

%%BeginSetup 
%%EndSetup 

%%Page: 1 1
%%BeginPageSetup 
 /pgsave save def     
%%EndPageSetup

  /Helvetica 24 selectfont 
 
  /is-blah-in-currentdict { 
    /blah is-known 
    {(/blah is in currentdict) ==}
    {(/blah is NOT in currentdict) ==} ifelse
  } def
 
  /blah 42 def
  is-blah-in-currentdict % yes

  3 dict begin
    is-blah-in-currentdict % no
  end 
 
  /blah discard
  is-blah-in-currentdict % no

  % str num
  /def-one-thing-at-a-time { 
    2 dict begin
      % def one item at a time
      /num defi 
      /text defi
      text ==
      num == 
    end
  } def
 
  (Buongiorno, amici!) 15 def-one-thing-at-a-time
  
  % str num
  /def-many-things-at-once { 
    2 dict begin
      % def all at once
      % the name-order matches the operand-order documented in the above comment
      [/first-name /age] defi
      first-name ==
      age ==
    end
  } def
  
  (Richard) 45 def-many-things-at-once

  % str num
  /def-many-things-at-once-more-compact {
    [/country /year] {
      (The country and year:) ==
      country ==
      year ==
      % one can def other items here, if needed
    } def-tmp
  } def

  (Italy) 2016 def-many-things-at-once-more-compact

pgsave restore
showpage
%%PageTrailer
%%Trailer    
%%EOF 