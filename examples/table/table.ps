%!PS-Adobe-3.0
%%Title: Tables
%%Version: 1.0
%%Creator: John O'Hanley
%%CreationDate: 2026-02-16
%%LanguageLevel: 3.0
%%DocumentMedia: Plain 612.0 792.0 60 white ()
%%DocumentNeededResources: font Helvetica Courier
%%BoundingBox: 0 0 612 792
%%Orientation: Portrait 
%%Pages: 1
%%EndComments 

%%BeginDefaults 
%%EndDefaults

%%BeginProlog

%  BASIC TABLES. THE CELLS ARE IMPLEMENTED AS PROCS, NOT AS DATA.

% table-dict
% See below for an example dict.
% Render a table as a collection of cells. Each cell is a proc.
% Return xs and ys on the stack, for the coords of all grid lines, in case the caller wants to render them in some custom manner.
% The caller can either translate the origin to the top left corner of the table, or pass /left and /top in the table-dict.
% The cells[[]] is an array of rows, top-down and left-to-right.
% Drawing to each cell is clipped to its rectangular box.
/basic-table {
30 dict begin 
  % put all of the names into the new currentdict
  {def} forall
  col-widths length   cells 0 get length   ne  {
    (DISAPPOINTMENT: the first row has an unexpected number of columns.) error-message
  }if

  % the position of the top-left corner
  % if not present in the currentdict, then these are def'd as 0:
  /left is-known not { /left 0 def } if
  /top is-known not { /top 0 def } if
  
  % defs: /bottom /right /xs /ys
  % the position of the bottom-right corner is calculated from col-widths and row-ht
  % xs and ys are the locations of vertical and horizontal grid lines, respectively
  /locate-grid-lines {
    /xs col-widths length 1 add array def
    xs 0 left put 
    1  1  xs length 1 sub {
      /i exch def
      xs i    
        xs i 1 sub get         % previous
        col-widths i 1 sub get % add col-width
      add  
      put
    } for
    % do the same for ys
    /ys cells length 1 add array def 
    ys 0 top put 
    1   1   ys length 1 sub {
      /i exch def
      ys  i  
      top   row-ht i mul   sub
      put
    } for
    /bottom ys last-entry def
    /right xs last-entry def
    /i discard
  } def
  
  /draw-the-grid {
    newpath
    % vertical lines, top to bottom, then left to right
    0   1   xs length 1 sub {
      xs exch get   top   moveto
      0   bottom top sub   rlineto  % line down
    } for
    % horizontal lines, left to right, then top to bottom
    0   1   ys length 1 sub {
      ys exch get  left exch   moveto
      right left sub  0  rlineto  % line to the right
    } for
    stroke
  } def

  % i j -> x y w h  
  % translate 0-based cell indices (i,j) into the numbers describing the geometry of the cell's box:
  % xy coords for the bottom left of the cell, and its width and height
  /cell-indices-to-xywh {
    2 dict begin
      /j exch def
      /i exch def
      % let's compute these critters directly on the operand stack
      % x = left + sum(col-widths 0..j-1) IF j is > 0
      left  
      j 0 gt {
        0   1  j 1 sub {
          col-widths exch get add 
        } for
      } if
      % y = top - (i+1) * row-ht
      top  i 1 add  row-ht  mul   sub 
      col-widths j get   % w
      row-ht             % h
    end
  } def
  
  % pct pct 
  % move to an arbitrary spot in the interior of a cell.
  % uses percent-width, percent-height of the cell.
  % WARNING: this is a low-level 'back-up', in case of need.
  % you'll see a different 'padding' when the column-width is different!
  /goto {
    % px py
    ht exch pct % px y
    exch % y px
    wd exch pct % y x 
    exch 
    moveto
  } def
  
  % PROCS THAT CAN BE USED TO CONTROL HOW THE CELL IS MARKED:
  
  % str 
  % left-align text within a cell
  /LF {pad pad moveto   show} def 
  
  % str 
  % right-align text within a cell
  /RT {wd pad sub   pad moveto   show-right-align} def 
  
  % str 
  % middle-x the text within a cell
  /MID {wd 50 pct   pad  moveto  show-ctr-x} def 
  
  % str
  % center-xy text within a cell
  /CTR {50 50 goto show-ctr-xy} def 

  % TRANSLATE to the middle of the cell
  /T-MID {wd 50 pct  ht 50 pct translate} def 
  
  % gray-value 0..1
  % shade the whole cell using a grayscale value
  /SHADE {
    gsave 
      setgray 
      0 0 wd ht rectfill
      0 0 wd ht rectstroke
    grestore
  } def 
  
  % Use a font for numbers.
  /NUM { /Courier 12 selectfont} def
  
  % Use a font for text.
  /TXT { /Helvetica 12 selectfont } def

  % mark all of the cells  
  /mark-cells {
    0  1   cells length 1 sub {
      % over rows
      /i exch def
      0  1   cells 0 get length 1 sub {
        /j exch def
        % over columns
        i j cell-indices-to-xywh
        4 copy  % to consume x y w h twice
        gsave 
          rectclip % clip to the cell's rect
          4 2 roll % w h x y
          translate % translate to the bottom left of the cell
          /ht exch def
          /wd exch def
          mark-the-cell % uses: i j ht wd in the currentdict
        grestore
      } for
    } for
  } def

  % mark a single cell
  %  
  % the cell consists of one thing: a proc that marks the cell!
  % this is the 'maximally flexible' design: it's not based on data-plus-policies, but on CODE.
  % the cell 'knows' the origin is the bottom left of the cell.
  /mark-the-cell {
    % just call the proc attached to the cell! nice!
    cells i get j get exec 
  } def

  % finally, mark the table using the proc's defined above  
  locate-grid-lines
  mark-cells
  % in some cases, you won't want to draw a grid at all
  show-all-grid-lines? {
    draw-the-grid 
  } if
  % the caller may want to draw the grid in a custom manner, so 
  % we always return the locations of all possible grid lines
  xs
  ys 
end
} def


% BELOW ARE PROCS THAT AREN'T SPECIFICALLY RELATED TO TABLES, BUT 
% ARE USED BY THE basic-table PROCEDURE ABOVE.

% pass two numbers; a value and a percent
% example '70 15 pct' is 15% of 70
% note that 15% is represented here as '15', not as '0.15'
% this simple proc is very widely used!
/pct {
 0.01 mul mul
} bind def

% multiple of the height of small 'x' in the current font
/ex {
 (x) text-height mul
} def

% key 
% return true iff the key is in the currentdict
/is-known {
 currentdict exch known
} bind def

% key
% 'un-def' the given key from the currentdict
/discard {
 currentdict exch undef  
} bind def

% array
% return the last item in an array
/last-entry {
  dup  length 1 sub   get
} def

% str
% return the width/height (dx, dy) of the given text (in the current font)
% this is useful for centering in various ways
% https://stackoverflow.com/questions/3618194/how-to-determine-string-height-in-postscript luser droog
/text-dim {
  gsave
    0 0 moveto
    % the bounding box of the text
    false charpath flattenpath pathbbox % x0 y0 x1 y1
  grestore
  3 -1 roll sub % x0 x1 dy
  3 1 roll sub % dy -dx
  -1 mul % dy dx
  exch % dx dy
}
bind def

% str -> number
% height of the given string in the current font
/text-height {
  text-dim % dx dy
  exch pop % dy 
} def

% text 
% center text horizontally AND vertically at the currentpoint
% WARNING: centering text vertically can give mediocre results (variations in text ascenders etc.)
/show-ctr-xy {
  dup text-dim % text dx dy
  -2 div % text dx -dy/2
  exch % text -dy/2 dx
  -2 div exch % text -dx/2 -dy/2
  rmoveto % text
  show
} bind def

% text 
% center text horizontally at the currentpoint
/show-ctr-x {
  dup text-dim pop % text dx
  -2 div % text -dx/2
  0 rmoveto % text
  show
} bind def

% text 
% right-align text horizontally at the currentpoint
/show-right-align {
  dup text-dim pop % text dx
  -1 mul % text -dx
  0 rmoveto % text
  show
} bind def

% draw a flower at the center of the cell.
% this demonstrates how you can put anything you want into a cell, because
% cells are implemented as procs, not data.
/FLOWER {
  wd 50 pct  ht 50 pct translate
  8 dup scale
  1 dict begin
    /flower-petal {
      newpath
        0 0 moveto      % center
        1 0 translate   % mark a straight line 
        15 rotate       % rotate the axis (no mark)
        0 15 sin translate  % go 'up' a bit, to the center of the arc
        0 0 15 sin -90 90 arc  % mark the arc
      closepath         % back to the center
    } def
    gsave 
      0.02 setlinewidth
      0.85 setgray
      1 1 12 {
        gsave
         flower-petal gsave fill grestore  % the gray insides
         0 setgray stroke  % the dark outline
        grestore
        30 rotate
      } for
    grestore
  end
} def
  


%%EndProlog

%%BeginSetup               
  /page-width  8.5 72 mul def
  /page-height 11 72 mul def % absolute values
  <</PageSize [page-width  page-height]>> setpagedevice  
  << /NeverEmbed [ ] >> setdistillerparams  % always embed fonts
  true setstrokeadjust  % minimizes off-by-one-pixel line issues
%%EndSetup 

%%Page: 1 1
%%BeginPageSetup 
 /pgsave save def     
%%EndPageSetup

  /Helvetica 12 selectfont 
  /wd page-width def
  /ht page-height def
  
  wd 10 pct 
  ht 90 pct moveto (Example Table: ) show

  wd 10 pct 
  ht 85 pct translate % to the top-left of the table  
  <<  
    /row-ht 4 ex
    /col-widths [wd 10 pct  wd 10 pct  wd 10 pct  wd 10 pct]
    /pad 0.8 ex
    /show-all-grid-lines? true
    /cells [ 
      [ {TXT(P1)MID} {NUM(23:18)RT} {NUM(18.4)CTR} {0.85 SHADE TXT(SSE)LF} ]
      [ {TXT(U1)MID} {NUM(09:23)RT} {NUM(36.2)CTR} {TXT(NW)LF} ]
      [ {TXT(U1)MID} {NUM(12:59)RT} {NUM(27.9)CTR} {FLOWER} ]
    ]
  >>
  basic-table
  pop pop % because we don't use the returned xs and ys in this case
  
pgsave restore
showpage
%%PageTrailer
%%Trailer    
%%EOF 